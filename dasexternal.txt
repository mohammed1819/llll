1)
a)
Vector — definition & example

Definition (short): A vector is a 1-dimensional homogeneous data structure in R; all elements must be of the same basic type (numeric, integer, character, logical, etc.). Vectors are the most common basic object in R and support vectorized operations
# numeric vector
v_num <- c(10.5, 20.0, 30.25, 40)

# integer vector
v_int <- c(1L, 2L, 3L, 4L)

# character vector
v_chr <- c("apple", "banana", "cherry")

# logical vector
v_log <- c(TRUE, FALSE, TRUE)

List — definition & example

Definition (short): A list is an ordered collection that can contain heterogeneous elements — vectors, matrices, data.frames, functions, other lists, etc. Lists are used whenever different types or structures must be kept together.

my_list <- list(
  id = 101,
  name = "Alice",
  scores = c(89, 92, 75),
  meta = list(gender = "F", enrolled = TRUE)
)
str(my_list)


b)
Vector arithmetic (element-wise / vectorized)

Notes:

Operations are element-wise.

If lengths differ, R recycles the shorter vector (with a warning when not an integer multiple).
a <- c(2, 4, 6, 8)
b <- c(1, 2, 3, 4)

# element-wise
add_v   <- a + b       # summation
sub_v   <- a - b       # subtraction
mult_v  <- a * b       # multiplication
div_v   <- a / b       # division

# scalar with vector
add_scalar <- a + 5
mult_scalar <- a * 2

# recycling example (shorter vector)
c <- c(10, 20)
recycle_add <- a + c   # 10,20,10,20 recycled
List arithmetic — approaches & examples

Notes:

Lists are not vectorized by default. You cannot do list1 + list2 directly.

If the list elements are numeric vectors of equal length, use Map, mapply, or lapply with appropriate functions. Or convert lists to vectors (unlist) if appropriate.
R code — case 1: lists contain numeric vectors of same length

L1 <- list(x = c(2,4,6), y = c(10,20,30))
L2 <- list(x = c(1,1,1),  y = c(5,5,5))

# element-wise addition on corresponding elements
sum_list <- Map(function(u,v) u + v, L1, L2)
str(sum_list)

case - 2
lists contain single numeric elements

L3 <- list(a = 10, b = 20)
L4 <- list(a = 2,  b = 5)

# use mapply to get elementwise numeric operations (returns vector)
sum_simple <- mapply(function(x,y) x + y, L3, L4)
prod_simple <- mapply(function(x,y) x * y, L3, L4)

case 3: lists with different structures (use unlist where appropriate)

L5 <- list(1, 2, 3)
L6 <- list(10,20,30)

# convert to numeric vectors then compute
v5 <- unlist(L5) #flattens the list 
v6 <- unlist(L6)
v_sum <- v5 + v6   # c(11,22,33)




c)
data(iris)

# Select numeric columns
num_data <- iris[,1:4]

# Correlation matrix
cor_matrix <- cor(num_data)
cor_matrix

# Correlation plot
library(corrplot)
corrplot(cor_matrix, method="color", addCoef.col="black",
         tl.col="black", number.cex=0.7,
         title="Correlation Plot - Iris Dataset")
Short explanation to write:

Iris numeric variables show strong positive correlations between Petal.Length and Petal.Width (~0.96).

Sepal.Length also correlates strongly with petal measurements (~0.87 & ~0.82).

Sepal.Width shows weak negative correlation with petal variables.

Corrplot visualizes strength and direction of relationships using color intensity.














2)
a)
A matrix is a 2-D homogeneous rectangular data structure in R (all elements same atomic type). Create with matrix(), or by combining vectors with rbind() / cbind(). Subsetting uses [row, column] indexing (1-based).
# Create a matrix (by column, default)
M1 <- matrix(1:9, nrow = 3, ncol = 3)   # fills column-wise: 1 4 7 ; 2 5 8 ; 3 6 9
M1

# Create matrix by row (use byrow = TRUE)
M2 <- matrix(c(10,11,12, 13,14,15), nrow = 2, byrow = TRUE)
M2

# Named row/column indices (optional)
rownames(M1) <- c("r1","r2","r3")
colnames(M1) <- c("c1","c2","c3")
M1

# Subsetting
M1[1,2]        # element at row1, col2
M1[2, ]        # entire row2
M1[ ,3]        # entire column3
M1[1:2, 2:3]   # block: rows 1-2, cols 2-3

# Logical or index-based subsetting
M1[M1 > 5]     # returns all elements > 5 (vector)
M1[c(1,3), c(1,3)]  # rows 1 & 3, cols 1 & 3



b)
# Two compatible matrices
A <- matrix(c(1,2,3, 4,5,6), nrow = 2, byrow = TRUE)   # 2x3
B <- matrix(c(6,5,4, 3,2,1), nrow = 2, byrow = TRUE)   # 2x3
A; B

# Addition and subtraction (element-wise)
C_add  <- A + B
C_sub  <- A - B
C_mul  <- A * B       # element-wise multiplication
C_div  <- A / B       # element-wise division

# Matrix multiplication (linear algebra) - dimensions must match: (2x3) %*% (3x2)
# Create compatible matrices
X <- matrix(1:6, nrow = 2)    # 2x3
Y <- matrix(1:6, nrow = 3)    # 3x2
MatProd <- X %*% Y            # result 2x2

# Add row and column
A_with_row <- rbind(A, c(7,8,9))        # add a third row
A_with_col <- cbind(A, c(10,11))        # add a fourth column (adds column to 2x3 -> 2x4)

# Remove row/col (example)
A_removed_row <- A_with_row[-3, ]       # remove row 3
A_removed_col <- A_with_col[, -4]       # remove column 4

# Show results
C_add; C_sub; C_mul; C_div
MatProd
A_with_row; A_with_col




c)
# Data
X <- c(2,4,5,6,8)
Y <- c(60,75,80,85,95)
n <- length(X)

# Means
meanX <- mean(X)   # 5
meanY <- mean(Y)   # 79

# Deviations
dx <- X - meanX
dy <- Y - meanY

# Sums needed
sum_dx2 <- sum(dx^2)         # 20
sum_dy2 <- sum(dy^2)         # 670
sum_dxdy <- sum(dx * dy)     # 115

# Manual Pearson r (raw-sum formula)
r_manual <- sum_dxdy / sqrt(sum_dx2 * sum_dy2)
r_manual


# Verify with built-in cor()
r_cor <- cor(X, Y)

r_manual
r_cor










3)
a)
A data.frame is a 2-D tabular structure in R that can hold columns of different types (numeric, factor, character, logical). Use data.frame() to create, str() and head() to inspect.
# Create vectors first
id <- 1:5
name <- c("Asha", "Bala", "Chirag", "Divya", "Ehsan")
age <- c(21, 22, 20, 23, 22)
marks <- c(78, 85, 69, 92, 88)
passed <- c(TRUE, TRUE, FALSE, TRUE, TRUE)

# Create dataframe
students <- data.frame(ID = id,
                       Name = name,
                       Age = age,
                       Marks = marks,
                       Passed = passed,
                       stringsAsFactors = FALSE)

# Inspect
str(students)
head(students)



b)
# Structure
str(students)

# Summary (descriptive statistics)
summary(students)

# More numeric summaries (column-wise)
sapply(students[, c("Age", "Marks")], mean)
sapply(students[, c("Age", "Marks")], sd)
sapply(students[, c("Age", "Marks")], median)


new_row <- data.frame(ID = 6, Name = "Farah", Age = 21, Marks = 81, Passed = TRUE, stringsAsFactors = FALSE)
students2 <- rbind(students, new_row)
# Check
tail(students2)

# Add a column using cbind (ensure same number of rows)
extra_col <- c("City1","City2","City3","City4","City5","City6")
students2 <- cbind(students2, City = extra_col)

# Inspect updated df
str(students2)
head(students2)



c)
# 1. Load iris dataset
data(iris)

# 2. Take numeric columns
iris_num <- iris[, 1:4]

# 3. Standardize features (recommended for K-means)
iris_scaled <- scale(iris_num)

# 4. Apply K-means (k = 3 for iris)
set.seed(42)
km_res <- kmeans(iris_scaled, centers = 3, nstart = 25)

# 5. Show cluster centers (scaled)
km_res$centers

# 6. Table of cluster vs Species
table(km_res$cluster, iris$Species)

# 7. Clusplot (cluster visualization)
library(cluster)
clusplot(iris_scaled, km_res$cluster,
         color = TRUE, shade = TRUE, labels = 2, lines = 0,
         main = "K-means Clustering of Iris Dataset")














4)
a)
The Fibonacci sequence starts 0, 1, 1, 2, 3, 5, 8, ... where each term after the first two is the sum of the two previous terms. The function below returns all Fibonacci numbers <= n (i.e., up to a given maximum number n).
# Fibonacci up to given max value 'n' (inclusive)
fib_upto <- function(n) {
  if (!is.numeric(n) || length(n) != 1 || n < 0) stop("n must be a single non-negative number")
  if (n < 1) return(0)      # If they want 0 when n < 1
  a <- 0
  b <- 1
  seq <- c(a)
  while (b <= n) {
    seq <- c(seq, b)
    tmp <- a + b
    a <- b
    b <- tmp
  }
  return(seq)
}

# Examples
fib_upto(0)     # -> 0
fib_upto(1)     # -> 0 1 1
fib_upto(20)    # -> 0 1 1 2 3 5 8 13


b)
df <- data.frame(
  id = 1:10,
  marks = c(78,85,69,92,88,74,81,60,95,72),
  sleep_hrs = c(7,6,8,5,7,7,6,8,6,7),
  study_hrs = c(3,4,2,5,4,3,4,2,5,3),
  play_hrs  = c(1,2,1,0,2,3,1,2,0,1),
  gender = c("M","F","M","F","F","M","F","M","F","M"),
  passed = c("P","P","F","P","P","P","P","F","P","P")
)

# --- SUBSETTING ---
df[df$gender == "M", ]
df[df$passed == "P" & df$marks > 80, ]
df[df$gender == "F" & df$sleep_hrs >= 7, ]
df[df$passed == "F" | df$study_hrs < 3, ]
df[, c("id","marks","play_hrs")]
df[4:8, ]
df[, !(names(df) == "play_hrs")]

# --- AGGREGATION ---
aggregate(marks ~ gender, data=df, mean)
aggregate(study_hrs ~ passed, data=df, sum)
aggregate(sleep_hrs ~ passed, data=df, mean)
aggregate(play_hrs ~ gender, data=df, sum)
aggregate(marks ~ gender, df, function(x) c(mean=mean(x), sd=sd(x)))
tapply(df$marks, df$sleep_hrs, mean)



c)
# Data
internal <- c(15,23,18,23,24,22,22,19,19,16,24,11,24,16,23)
external <- c(49,63,58,60,58,61,60,63,60,52,62,30,59,49,68)

# Fit linear model: external ~ internal
model <- lm(external ~ internal)

# Regression summary
summary(model)

# Extract coefficients and residuals
coef(model)       # intercept and slope
residuals(model)  # residuals (vector)

# Predicted values
fitted_vals <- fitted(model)

# Plot: data + regression line
plot(internal, external, pch=19, xlab="Internal marks", ylab="External marks",
     main="Linear regression: External ~ Internal")
abline(model, col = "blue", lwd = 2)














5)
a)
# --- simple calculator functions (R objects) ---
add <- function(x, y) x + y
sub <- function(x, y) x - y
mul <- function(x, y) x * y
div <- function(x, y) {
  if (y == 0) stop("Division by zero not allowed")
  x / y
}

# Example usage (sample session stored in a list)
session1 <- list(
  a = 12,
  b = 5,
  sum = add(12, 5),
  diff = sub(12, 5),
  prod = mul(12, 5),
  quot = div(12, 5)
)

# Print session
session1


b)
# Sample data to write
df <- data.frame(
  id = 1:5,
  value = c(10, 20, 30, 40, 50)
)

# ----------------------------
# 1. READ existing CSV file
# ----------------------------
csv_path <- "C:/Users/YourName/Documents/input_file.csv"   # assume it already exists
csv_data <- read.csv(csv_path)
print(csv_data)

# ----------------------------
# 2. READ existing TXT file
# ----------------------------
txt_path <- "C:/Users/YourName/Documents/input_file.txt"   # assume it already exists
txt_data <- read.table(txt_path, header = TRUE, sep = "\t")
print(txt_data)

# ----------------------------
# 3. WRITE new CSV file
# ----------------------------
out_csv <- "C:/Users/YourName/Documents/output_data.csv"
write.csv(df, file = out_csv, row.names = FALSE)

# ----------------------------
# 4. WRITE new TXT file
# ----------------------------
out_txt <- "C:/Users/YourName/Documents/output_data.txt"
write.table(df, file = out_txt, sep = "\t", row.names = FALSE, quote = FALSE)

# Print confirmation
print("CSV and TXT files created successfully!")



c)
# --- K-means on mtcars (clean version) ---
data(mtcars)
head(mtcars)

# keep data (mtcars is numeric)
mt <- mtcars

# scale for clustering (recommended)
mt_scaled <- scale(mt)

# run kmeans
set.seed(123)
k <- 3
km <- kmeans(mt_scaled, centers = k, nstart = 25)

# cluster centers in scaled units
km$centers

# cluster sizes
km$size

# cross-tab with cylinders for interpretation
table(Cluster = km$cluster, Cylinders = mt$cyl)

# draw clusplot (requires cluster package)
library(cluster)
clusplot(mt_scaled, km$cluster,
         color = TRUE, shade = TRUE, labels = 2, lines = 0,
         main = "K-means on mtcars (k=3) - 2D projection")

